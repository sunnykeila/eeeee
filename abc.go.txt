/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"context"
	"encoding/base64"
	"strings"
	"time"

	"fmt"

	"github.com/ghodss/yaml"
	"github.com/go-logr/logr"
	"github.com/jackc/pgx"
	"github.com/m1/go-generate-password/generator"
	postgresqlv1alpha1 "github.com/rds-operator/api/v1alpha1"
	coreV1 "k8s.io/api/core/v1"
	v1update "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

const SecretString string = `
apiVersion: v1
data:
  POSTGRES_PASSWORD: %s
  POSTGRES_USER: %s
  POSTGRES_URL: %s
kind: Secret
metadata:
  labels:
    application: postgresql
    team: rwil
  name: %s
  namespace: %s
type: Opaque
`

//erstelle password username name und namespace

// RdsPostgresReconciler reconciles a RdsPostgres object
type RdsPostgresReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups=postgresql.rdsoperator.com,resources=rdspostgres,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=postgresql.rdsoperator.com,resources=rdspostgres/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=postgresql.rdsoperator.com,resources=rdspostgres/finalizers,verbs=update

// DBConfig holds config information for creating a DB client
type DBConfig struct {
	Username string
	Password string
	Host     string
	Database string
	Product  string
}

var (
	sharedInstance = DBConfig{}
	gedaiConfig    = DBConfig{}
	xamConfig      = DBConfig{}

	motionwareConfig = DBConfig{}
)
var logg logr.Logger
var instance string

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the RdsPostgres object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.8.3/pkg/reconcile
func (r *RdsPostgresReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logg = log.FromContext(ctx)
	rdspostgres := &postgresqlv1alpha1.RdsPostgres{}
	err := r.Get(ctx, req.NamespacedName, rdspostgres)
	username := rdspostgres.Spec.Username
	instance = rdspostgres.Spec.Datenbank
	username = strings.ToLower(username)
	namespace := rdspostgres.ObjectMeta.Namespace

	err = getstagesecret(namespace, ctx)
	if err != nil {
		logg.Error(err, "Error while getting the RDS Instances for the stage")
		return ctrl.Result{}, err
	}

	client, err := InitDBConnection(instance)
	if err != nil {
		logg.Error(err, "Creating DB client")
		return ctrl.Result{}, err
	}
	if client.DatabaseExists(username) {
		return ctrl.Result{}, nil
	}
	servicename := rdspostgres.ObjectMeta.Name
	randomPW, err := CreatePassword()
	if err != nil {
		fmt.Println(err)
		return ctrl.Result{}, err
	}
	err = client.CreateUser(username, randomPW)
	if err != nil {
		logg.Info(err.Error())
		logg.Info("Achtung fehler nach erstellung des Users das password für den user ist :" + randomPW)
		return ctrl.Result{}, err
	}
	defer client.Close()
	//log in with user change connection and paste it back
	time.Sleep(time.Second * 1)
	newUserDB, err := logInWithNewUser(username, randomPW, instance)
	time.Sleep(time.Second * 1)
	if err != nil {
		// TODO use the logger instead
		logg.Info(err.Error())
		logg.Info("Achtung fehler nach erstellung des Users das password für den user ist :" + randomPW)
		return ctrl.Result{}, err
	}
	newUserDB.CreateDatabase(username)
	defer newUserDB.Close()

	if err != nil {
		fmt.Println(err)
		logg.Info("Achtung fehler nach erstellung des Users das password für den user ist :" + randomPW)
		return ctrl.Result{}, err
	}

	err = CreateKubernetesSecret(ctx, username, randomPW, getinstanceurl(instance), namespace, servicename+"-rds")
	if err != nil {
		logg.Info("Achtung fehler nach erstellung des Users das password für den user ist :" + randomPW)
		return ctrl.Result{}, err

	}
	logg.Info("Secret " + servicename + "-rds erstellt in namespace " + namespace)
	return ctrl.Result{}, nil
}

//transfed the db config via call by reference
func decrypt(todecrypt []byte) string {
	todecryptstring := string(todecrypt)
	//dectrypted, err := base64.StdEncoding.DecodeString(todecryptstring)
	return todecryptstring

}

/*func getconfigfromsecretcopy(conf DBConfig, data map[string][]byte) {
	conf.Database = string(data["database"])
	conf.Host = string(data["host"])
	conf.Password = string(data["password"])
	conf.Product = string(data["product"])
	conf.Username = string(data["username"])

}*/

func getconfigfromsecret(conf *DBConfig, data map[string]string) {
	//logg.Info(data["host"] + "host")
	conf.Database = data["database"]
	conf.Host = data["host"]
	conf.Password = data["password"]
	conf.Product = data["product"]
	conf.Username = data["username"]
	//logg.Info(sharedInstance.Host + "host der shared instance")

}
func getinstanceurl(instance string) string {
	var configs = make(map[string]DBConfig)
	configs["motionware"] = motionwareConfig
	configs["gedai"] = gedaiConfig
	configs["xam"] = xamConfig
	configs["shared"] = sharedInstance
	return configs[instance].Host
}
func getstagesecret(namespace string, ctx context.Context) error {
	/*var configs map[string]DBConfig
	configs["motionware"] = motionwareConfig
	configs["gedai"] = gedaiConfig
	configs["xam"] = xamConfig
	configs["shared"] = sharedInstance
	*/
	namespace = "rds-system"
	config, err := rest.InClusterConfig()
	if err != nil {
		fmt.Println(err)
		return err
	}
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return err
	}

	secretsClient := clientset.CoreV1().Secrets(namespace)
	stagesecret, err := secretsClient.Get(ctx, "rds-stage", v1update.GetOptions{})
	if err != nil {
		return err
	}

	stage := string(stagesecret.Data["stagename"])
	if err != nil {
		return err
	}
	var parameter map[string]string
	parameter = make(map[string]string)
	if stage == "dev" {
		instance = "shared"
		instancessecrets, err := secretsClient.Get(ctx, "rds-rds-instances", v1update.GetOptions{})
		if err != nil {
			return err
		}
		logg.Info(stage)

		parameter["database"] = string(instancessecrets.Data["database"])
		parameter["host"] = decrypt(instancessecrets.Data["hostshared"])
		parameter["password"] = decrypt(instancessecrets.Data["passwordshared"])
		parameter["username"] = decrypt(instancessecrets.Data["username"])
		parameter["product"] = "shared"
		if err != nil {
			return err
		}
		getconfigfromsecret(&sharedInstance, parameter)
		logg.Info("daten eingefügt")
	} else {
		instancessecrets, err := secretsClient.Get(ctx, "rds-rds-instances", v1update.GetOptions{})
		if err != nil {
			return err
		}

		parameter["database"] = decrypt(instancessecrets.Data["database"])
		parameter["host"] = decrypt(instancessecrets.Data["hostmotionware"])
		parameter["password"] = decrypt(instancessecrets.Data["passwordmotionware"])
		parameter["username"] = decrypt(instancessecrets.Data["username"])
		parameter["product"] = "motionware"
		getconfigfromsecret(&motionwareConfig, parameter)
		parameter["host"] = decrypt(instancessecrets.Data["hostxam"])
		parameter["password"] = decrypt(instancessecrets.Data["passwordxam"])
		parameter["product"] = "xam"
		getconfigfromsecret(&xamConfig, parameter)
		parameter["host"] = decrypt(instancessecrets.Data["hostgedai"])
		parameter["password"] = decrypt(instancessecrets.Data["passwordgedai"])
		parameter["product"] = "gedai"
		getconfigfromsecret(&gedaiConfig, parameter)
	}

	return err
}
func CreateKubernetesSecret(ctx context.Context, username string, password string, instanceurl string, namespace string, secretname string) error {
	config, err := rest.InClusterConfig()
	if err != nil {
		fmt.Println(err)
		return err
	}
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return err
	}

	secretsClient := clientset.CoreV1().Secrets(namespace)

	usernameencoded := base64.StdEncoding.EncodeToString([]byte(username))
	passwordencoded := base64.StdEncoding.EncodeToString([]byte(password))
	instanceurlencoded := base64.StdEncoding.EncodeToString([]byte(instanceurl))
	secret, err := CreateSecret(usernameencoded, passwordencoded, instanceurlencoded, secretname, namespace)
	if err != nil {
		logg.Error(err, "Creating secret spec")
		return err
	}

	_, err = secretsClient.Create(ctx, &secret, v1update.CreateOptions{FieldManager: "VaultUser"})
	if err != nil {
		return err
	}

	logg.Info("secret " + secretname + " erstellt")
	return nil

}
func logInWithNewUser(username string, password string, product string) (*PostgreSQLClient, error) {
	var psqlclient PostgreSQLClient
	var err error
	switch product {
	case "gedai":
		resetsafe := gedaiConfig
		gedaiConfig.Username = username
		gedaiConfig.Password = password
		psqlclient, err = InitDBConnection(product)
		gedaiConfig = resetsafe
	case "motionware":
		resetsafe := motionwareConfig
		motionwareConfig.Username = username
		motionwareConfig.Password = password
		psqlclient, err = InitDBConnection(product)
		motionwareConfig = resetsafe
	case "xam":
		resetsafe := xamConfig
		xamConfig.Username = username
		xamConfig.Password = password
		psqlclient, err = InitDBConnection(product)
		xamConfig = resetsafe
	case "shared":
		resetsafe := sharedInstance
		sharedInstance.Username = username
		sharedInstance.Password = password
		psqlclient, err = InitDBConnection(product)
		sharedInstance = resetsafe
	}
	if err != nil {
		return &PostgreSQLClient{}, err
	}
	return &psqlclient, nil
}

type PostgreSQLClient struct {
	// Connection to the actual PostgreSQL DB
	Conn    *pgx.Conn
	Product string
}

func (c *PostgreSQLClient) Close() {
	c.Conn.Close()
}

func (c *PostgreSQLClient) DatabaseExists(dbname string) bool {
	rows, err := c.Conn.Query("select datname from pg_database;")
	if err != nil {
		logg.Error(err, "Checking if database exists failed")
		return false
	}
	var databases []byte

	for rows.Next() {
		rows.Scan(&databases)
		if strings.Contains(string(databases), dbname) {
			logg.Info("database already exists")
			return true
		}
	}

	return false
}

func (c *PostgreSQLClient) CreateDatabase(databasename string) error {
	_, err := c.Conn.Query("CREATE DATABASE " + databasename + ";")
	if err != nil {
		return nil
	}
	return err
	//return err or bool?
}
func (c *PostgreSQLClient) CreateUser(username string, password string) error {
	_, err := c.Conn.Query(fmt.Sprintf("CREATE ROLE %s CREATEDB LOGIN PASSWORD '%s';", username, password))
	if err != nil {
		return nil
	}
	return err
}

func CreatePassword() (string, error) {
	config := generator.Config{
		Length:                     13,
		IncludeSymbols:             false,
		IncludeNumbers:             true,
		IncludeLowercaseLetters:    true,
		IncludeUppercaseLetters:    true,
		ExcludeSimilarCharacters:   true,
		ExcludeAmbiguousCharacters: true,
	}
	g, err := generator.New(&config)
	if err != nil {
		return "", err
	}
	pwd, err := g.Generate()
	if err != nil {
		return "", err
	}
	return *pwd, err
}

func GetDBClientFromConfigForNewUser(cfg DBConfig, username string, password string) (PostgreSQLClient, error) {
	db, err := pgx.Connect(pgx.ConnConfig{
		Host:     cfg.Host,
		Port:     5432,
		User:     username,
		Password: password,
		Database: cfg.Database,
	})
	if err != nil {
		return PostgreSQLClient{}, err
	}

	return PostgreSQLClient{
		Conn:    db,
		Product: cfg.Product,
	}, nil
}

func GetDBClientFromConfig(cfg *DBConfig) (PostgreSQLClient, error) {
	db, err := pgx.Connect(pgx.ConnConfig{
		Host:     cfg.Host,
		Port:     5432,
		User:     cfg.Username,
		Password: cfg.Password,
		Database: cfg.Database,
	})
	/*logg.Info(cfg.Host + " host")
	logg.Info(cfg.Username + " host")
	logg.Info(cfg.Password + " host")
	logg.Info(cfg.Database + " host")*/
	if err != nil {
		logg.Info(err.Error() + " hier sitzt der error begraben")
		return PostgreSQLClient{}, err
	}

	return PostgreSQLClient{
		Conn:    db,
		Product: cfg.Product,
	}, nil
}

func InitDBConnection(product string) (PostgreSQLClient, error) {
	var (
		client PostgreSQLClient
		err    error
	)

	switch product {
	case "gedai":
		client, err = GetDBClientFromConfig(&gedaiConfig)
	case "motionware":
		client, err = GetDBClientFromConfig(&motionwareConfig)
	case "xam":
		client, err = GetDBClientFromConfig(&xamConfig)
	case "shared":
		//logg.Info(sharedInstance.Host + " hier der host")
		client, err = GetDBClientFromConfig(&sharedInstance)
	}

	return client, err
}

func CreateSecret(username, password, instanceurl, name, namespace string) (coreV1.Secret, error) {
	secretSpec := fmt.Sprintf(SecretString, password, username, instanceurl, name, namespace)
	secretBytes := []byte(secretSpec)

	var secret coreV1.Secret
	err := yaml.Unmarshal(secretBytes, &secret)
	if err != nil {
		return coreV1.Secret{}, err
	}

	return secret, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *RdsPostgresReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&postgresqlv1alpha1.RdsPostgres{}).
		Complete(r)
}
